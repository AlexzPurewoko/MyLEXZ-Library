/*
 * Copyright (C) 2018 by Alexzander Purwoko Widiantoro
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


/* DO NOT EDIT THIS FILE - it is machine generated */
#include "MyLEXZ-Cutils/data_op/NodeData.h"
#include "com_mylexz_utils_NodeData.h"
#ifdef _Included_com_mylexz_utils_NodeData
typedef struct __lstNDATA{
	NDATA *data;
	int __desc;
	struct __lstNDATA *ptr;
}lNDATA;
jint __getNDesc(JNIEnv *, jobject);
void __setNDesc(JNIEnv *, jobject, jint);
lNDATA *__insertlN(lNDATA *, lNDATA *);
lNDATA *__relNode(lNDATA *, int);
lNDATA *__creatNode();
NDATA *__lNcont(lNDATA *, int); 
int __genDesc(lNDATA *);
jobject _htmp;
jobject getOSTR(JNIEnv *env, jobject thiz, const char *s){
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, s, "Ljava/lang/String;");
	return (*env)->GetObjectField(env, thiz, fid);
}
lNDATA *__lntemp, *__lncurr = NULL;
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_open(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc != -1)return;
	__lntemp = __creatNode();
	__desc = __genDesc(__lncurr);
	__lntemp -> __desc = __desc;
	__lntemp -> ptr = NULL;
	jstring filename = getOSTR(env, thiz, "__filepath");
	jstring signature = getOSTR(env, thiz, "__signature");
	const char *fnm = (*env)->GetStringUTFChars(env, filename, 0);
	const char *snm = (*env)->GetStringUTFChars(env, signature, 0);
	__lntemp -> data = nopen(fnm, snm);
	(*env)->ReleaseStringUTFChars(env, filename, fnm);
	(*env)->ReleaseStringUTFChars(env, signature, snm);
	int err = nget_error(__lntemp -> data);
	if(err != 0) {
		__lntemp = __relNode(__lntemp, __desc);
		return;
	}
	__lncurr = __insertlN(__lncurr, __lntemp);
	__setNDesc(env, thiz, __desc);
	return;
}

JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_close(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return -1;
	__lncurr = __relNode(__lncurr, __desc);
	__setNDesc(env, thiz, -1);
	return 0;
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addNode(JNIEnv *env, jobject thiz, jstring path, jstring node){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(node == NULL)return;
	if(path == NULL) elm = NULL;
	else elm = (*env)->GetStringUTFChars(env, path, 0);
	dt = (*env)->GetStringUTFChars(env, node, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nadd_node(d, elm, dt);
	if(elm) (*env)->ReleaseStringUTFChars(env, path, elm);
	(*env)->ReleaseStringUTFChars(env, node, dt);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_delNode(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	ndel_node(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_clearContents(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	nclear_body(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT jobjectArray JNICALL Java_com_mylexz_utils_NodeData_listContents(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	const char *fp;
	jobjectArray p;
	if(fullpath == NULL)fp = NULL;
	else fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d) {
		if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	off_t __select_datanode__(NDATA *, struct __nodeName__ *);
	register int _x = 0, _c, _npos, _y = 0;
	if (!fp)
	{
		_npos = 0;
		while ((_c = getc(_open)) != -1)
		{
			if (_c == _N_BUKA_)
				_npos++;
			if (_c == _N_TUTUP_)
				_npos--;
			if (_npos == 0)
				if (_c == _N_ID_ || _c == _C_ID_ || _c == _ARR_ID_)
					_x++;
		}
		if (_x == 0)
		{
			fseek(_open, *_sigPos, 0);
			*_errnum = ECN;
			if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
			return NULL;
		}
		__mem_rel__(d);
		// allocate for __content
		fseek(_open, *_sigPos, 0);
		_npos = 0;
		p = (*env) -> NewObjectArray(env, _x, (*env) -> FindClass(env, "java/lang/String"), NULL);
		int sym[3];
		while ((_c = getc(_open)) != -1)
		{
			if (_c == _N_BUKA_)
				_npos++;
			if (_c == _N_TUTUP_)
				_npos--;
			if (_npos == 0)
				if (_c == _N_ID_ || _c == _C_ID_ || _c == _ARR_ID_)
				{
					_x = 0;
					if (_c == _N_ID_)
					{
						sym[0] = '(';
						_npos++;
					}
					if (_c == _C_ID_ || _c == _ARR_ID_)
					{
						if (_c == _C_ID_)
							sym[0] = '<';
						else
							sym[0] = '>';
						_c = getc(_open);
						switch (_c)
						{
						case BOOL:
							sym[1] = 'b';
							break;
						case INT:
							sym[1] = 'i';
							break;
						case CHR:
							sym[1] = 'c';
							break;
						case DOUBLE:
							sym[1] = 'F';
							break;
						case LONG:
							sym[1] = 'L';
							break;
						case STR:
							sym[1] = 's';
						}
					}
					if (sym[0] != '(')
						sym[2] = getc(_open);
					while ((_c = getc(_open)) != _N_BUKA_ && _c != _LEN_)
						_temp[_x++] = _c;
					_temp[_x] = '\0';
					if ((_c = sym[0]) == '<' || _c == '>')	__edStr__(_temp, DEC);
					if (sym[0] != '(')
					{
						_temp[_x++] = (char) sym[0];
						_temp[_x++] = (char) sym[1];
						_temp[_x++] = (char) sym[2];
						_temp[_x++] = '\0';
					}
					else
					{
						_temp[_x++] = (char) sym[0];
						_temp[_x++] = '\0';
					}
					(*env) -> SetObjectArrayElement(env, p, _y, (*env) -> NewStringUTF(env, _temp));
					_y++;
				}
		}
		if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
		fseek(_open, *_sigPos, 0);
		*_errnum = NE;
		return p;
	}
	struct __nodeName__ *__path = __con_pathNode__(fp);
	off_t off1 = __select_datanode__(d, __path);
	if (off1 == -1)
	{
		*_errnum = EENF;
		fseek(_open, *_sigPos, 0);
		return NULL;
	}
	// getting length
	fseek(_open, off1, 0);
	_npos = 1;
	_x = 0;
	while (_npos != 0)
	{
		_c = getc(_open);
		if (_c == _N_BUKA_)
			_npos++;
		if (_c == _N_TUTUP_)
			_npos--;
		if (_c == -1)
			break;
		if (_npos == 1)
			if (_c == _N_ID_ || _c == _C_ID_ || _c == _ARR_ID_)
				_x++;
	}
	if (_x == 0)
	{
		fseek(_open, *_sigPos, 0);
		*_errnum = ECN;
		if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	fseek(_open, off1, 0);
	_npos = 1;
	int sym[3];
	p = (*env) -> NewObjectArray(env, _x, (*env) -> FindClass(env, "java/lang/String"), NULL);
	while (_npos != 0)
	{
		_c = getc(_open);
		if (_c == _N_BUKA_)
			_npos++;
		if (_c == _N_TUTUP_)
			_npos--;
		if (_npos == 1)
			if (_c == _N_ID_ || _c == _C_ID_ || _c == _ARR_ID_)
			{
				_x = 0;
				if (_c == _N_ID_)
				{
					sym[0] = '(';
					_npos++;
				}
				if (_c == _C_ID_ || _c == _ARR_ID_)
				{
					if (_c == _C_ID_)
						sym[0] = '<';
					else
						sym[0] = '>';
					_c = getc(_open);
					switch (_c)
					{
					case BOOL:
						sym[1] = 'b';
						break;
					case INT:
						sym[1] = 'i';
						break;
					case CHR:
						sym[1] = 'c';
						break;
					case DOUBLE:
						sym[1] = 'F';
						break;
					case LONG:
						sym[1] = 'L';
						break;
					case STR:
						sym[1] = 's';
					}
				}
				if (sym[0] != '(')
					sym[2] = getc(_open);
				while ((_c = getc(_open)) != _N_BUKA_ && _c != _LEN_)
					_temp[_x++] = _c;
				_temp[_x] = '\0';
				if ((_c = sym[0]) == '<' || _c == '>')__edStr__(_temp, DEC);
				if (sym[0] != '(')
				{
					_temp[_x++] = (char) sym[0];
					_temp[_x++] = (char) sym[1];
					_temp[_x++] = (char) sym[2];
					_temp[_x++] = '\0';
				}
				else
				{
					_temp[_x++] = (char) sym[0];
					_temp[_x++] = '\0';
				}
				(*env) -> SetObjectArrayElement(env, p, _y, (*env) -> NewStringUTF(env, _temp));
				_y++;
			}
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(fp) (*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return p;
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addIntData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jint data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	__android_log_print(ANDROID_LOG_INFO, "ADDINT", "VALUE DT = %s", (dt)?dt:"NULL");
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	sprintf(_temp, "%d", (int) data);
	if (encrypt_flags)__edNum__(_temp, ENC);
	
	
	// writing
	off_t offset = ftell(_open);
	if (!__path) fprintf(_open, "%c%c%c%s%c%d%c%s%c", _C_ID_, INT, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 1, _C_BUKA_, _temp, _C_TUTUP_);
	else
	{
		char *__ftmp = malloc(strlen(_filepath) + 4);
		sprintf(__ftmp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__ftmp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(INT, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		putc('1', _op1);
		putc(_C_BUKA_, _op1);
		_a = 0;
		for (; _temp[_a] != '\0'; _a++) putc(_temp[_a], _op1);
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		__android_log_print(ANDROID_LOG_INFO, "ADDINT", "VALUE __ftmp = %s, _filepath = %s.", (__ftmp)?__ftmp:"NULL", (_filepath)?_filepath:"NULL");
		rename(__ftmp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__ftmp);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
 }

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addLongData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jlong data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	sprintf(_temp, "%lld", (long long int) data);
	if (encrypt_flags)__edNum__(_temp, ENC);
	// writing
	off_t offset = ftell(_open);
	if (!__path) fprintf(_open, "%c%c%c%s%c%d%c%s%c", _C_ID_, LONG, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 1, _C_BUKA_, _temp, _C_TUTUP_);
	else
	{
		char __ftmp[strlen(_filepath) + 4];
		sprintf(__ftmp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__ftmp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(LONG, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		putc('1', _op1);
		putc(_C_BUKA_, _op1);
		_a = 0;
		for (; _temp[_a] != '\0'; _a++) putc(_temp[_a], _op1);
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		rename(__ftmp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addCharData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jchar data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	char _isi;
	if (encrypt_flags)_isi = (char) __encStr__((char)data);
	else _isi = (char) data;
	
	
	// writing
	off_t offset = ftell(_open);
	if (!__path) fprintf(_open, "%c%c%c%s%c%d%c%c%c", _C_ID_, CHR, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 1, _C_BUKA_, _isi, _C_TUTUP_);
	else
	{
		sprintf(_temp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(_temp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(CHR, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		putc('1', _op1);
		putc(_C_BUKA_, _op1);
		putc(_isi, _op1);
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		rename(_temp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addBoolData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jboolean data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	int __encNum__(int );
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	char _isi;
	if (encrypt_flags)_isi = (char) __encNum__((data)?'1':'0');
	else _isi = (data)?'1':'0';
	
	
	// writing
	off_t offset = ftell(_open);
	if (!__path) fprintf(_open, "%c%c%c%s%c%d%c%c%c", _C_ID_, BOOL, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 1, _C_BUKA_, _isi, _C_TUTUP_);
	else
	{
		sprintf(_temp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(_temp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(BOOL, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		putc('1', _op1);
		putc(_C_BUKA_, _op1);
		putc(_isi, _op1);
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		rename(_temp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addStrData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jstring data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);	
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	const char *cstr = (data!=NULL)?(*env) -> GetStringUTFChars(env, data, 0):NULL;	
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	// writing
	off_t offset = ftell(_open);
	if (!__path) 
		if(cstr){
			fprintf(_open, "%c%c%c%s%c%d%c", _C_ID_, STR, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, strlen(cstr), _C_BUKA_);
			if(encrypt_flags){
				int idx = strlen(cstr) - 1;
				int x;
				for(; idx >= 0; idx--){
					x = __encStr__(cstr[idx]);
					putc((char)x, _open);
				}
			}
			else{
				int x;
				for(x = 0; cstr[x] != '\0'; x++) putc(cstr[x], _open);
			}
			putc(_C_TUTUP_, _open);
		}
		else fprintf(_open, "%c%c%c%s%c%d%c%c", _C_ID_, STR, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 0, _C_BUKA_,  _C_TUTUP_);
	else
	{
		char *vt = _temp+strlen(_filepath)+5;
		sprintf(vt, "%d", (cstr)?strlen(cstr):0);
		sprintf(_temp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(_temp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(STR, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		_a = 0;
		for(; vt[_a] != '\0'; _a++)putc(vt[_a], _op1);
		putc(_C_BUKA_, _op1);
		if(cstr)
			if(encrypt_flags){
				int idx = strlen(cstr) - 1;
				int x;
				for(; idx >= 0; idx--){
					x = __encStr__(cstr[idx]);
					putc((char)x, _op1);
				}
			}
			else{
				int x;
				for(x = 0; cstr[x] != '\0'; x++) putc(cstr[x], _op1);
			}
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		rename(_temp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
		
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
	if(cstr) (*env)->ReleaseStringUTFChars(env, data, cstr);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addDoubleData(JNIEnv *env, jobject thiz, jstring path, jstring elem, jdouble data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(elem == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, elem, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, elem, elm);
		return;
	}
	char *__elem = malloc(strlen(elm));
	strcpy(__elem, elm);
	__edStr__(__elem, ENC);
	sprintf(_temp, "%lf", (double) data);
	if (encrypt_flags)__edNum__(_temp, ENC);
	// writing
	off_t offset = ftell(_open);
	if (!__path) fprintf(_open, "%c%c%c%s%c%d%c%s%c", _C_ID_, DOUBLE, ((encrypt_flags) ? '1' : '0'), __elem, _LEN_, 1, _C_BUKA_, _temp, _C_TUTUP_);
	else
	{
		char __ftmp[strlen(_filepath) + 4];
		sprintf(__ftmp, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__ftmp, "w+");
		fseek(_open, 0, 0);
		off_t _t = 0;
		for (; _t < offset; _t++)
			putc(getc(_open), _op1);
		putc(_C_ID_, _op1);
		putc(DOUBLE, _op1);
		putc(((encrypt_flags) ? '1' : '0'), _op1);
		register int _a = 0;
		for (; __elem[_a] != '\0'; _a++)
			putc(__elem[_a], _op1);
		putc(_LEN_, _op1);
		putc('1', _op1);
		putc(_C_BUKA_, _op1);
		_a = 0;
		for (; _temp[_a] != '\0'; _a++) putc(_temp[_a], _op1);
		putc(_C_TUTUP_, _op1);
		fseek(_open, offset, 0);
		while ((_a = getc(_open)) != -1)
			putc(_a, _op1);
		fclose(_open);
		fclose(_op1);
		rename(__ftmp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	free(__elem);
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, elem, elm);
}
JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getIntData(JNIEnv *env, jobject thiz, jstring fullpath, jint defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != INT)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_) _temp[_y++] = _x;
	_temp[_y] = '\0';
	if (_en_flags)__edNum__(_temp, DEC);
	// returning result
	jint res = atoi(_temp);
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jboolean JNICALL Java_com_mylexz_utils_NodeData_getBooleanData(JNIEnv *env, jobject thiz, jstring fullpath, jboolean defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != BOOL)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_) _temp[_y++] = _x;
	_temp[_y] = '\0';
	if (_en_flags)__edNum__(_temp, DEC);
	// returning result
	short res = (short) atoi(_temp);
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return (res)?TRUE:FALSE;
}

JNIEXPORT jlong JNICALL Java_com_mylexz_utils_NodeData_getLongData(JNIEnv *env, jobject thiz, jstring fullpath, jlong defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != LONG)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_) _temp[_y++] = _x;
	_temp[_y] = '\0';
	if (_en_flags)__edNum__(_temp, DEC);
	// returning result
	jlong res = (jlong) atoll(_temp);
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jdouble JNICALL Java_com_mylexz_utils_NodeData_getDoubleData(JNIEnv *env, jobject thiz, jstring fullpath, jdouble defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != DOUBLE)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_) _temp[_y++] = _x;
	_temp[_y] = '\0';
	if (_en_flags)__edNum__(_temp, DEC);
	// returning result
	jdouble res = (jdouble) strtod(_temp, (char **) NULL);
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jchar JNICALL Java_com_mylexz_utils_NodeData_getCharData(JNIEnv *env, jobject thiz, jstring fullpath, jchar defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != CHR)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_) _temp[_y++] = _x;
	_temp[_y] = '\0';
	char res;
	if (_en_flags)	res = __decStr__(_temp[0]);
	else res = _temp[0];
	// returning result
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return (jchar) res;
}

JNIEXPORT jstring JNICALL Java_com_mylexz_utils_NodeData_getStringData(JNIEnv *env, jobject thiz, jstring fullpath, jstring defV){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return defV;
	const char *fp;
	if(fullpath == NULL)return defV;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	// printf("%s %s\n", __path -> __name, _name);
	register int _y, _x;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != STR)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	__mem_rel__(d);
	// point into len char
	while ((_x = getc(_open)) != _LEN_);
	// getting length
	_y = 0;
	while ((_x = getc(_open)) != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	int _len = atoi(_temp);
	// passing into temporary
	if (_len == 0)
	{							// Null content
		free(_name);
		*_errnum = N_VAL;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return defV;
	}
	_y = 0;
	char res[_len];
	while ((_x = getc(_open)) != _C_TUTUP_) res[_y++] = _x;
	res[_y] = '\0';
	if (_en_flags)__edStr__(res, DEC);
	// returning result
	jstring ret = (*env) -> NewStringUTF(env, res);
	free(_name);
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return ret;
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2I(JNIEnv *env, jobject thiz, jstring fullpath, jint data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != INT)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	sprintf(_temp, "%d", (int)data);
	__edNum__(_temp, ENC);
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	// printf("%s", __ftmp);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	putc('1', _op1);
	putc(_C_BUKA_, _op1);
	_y = 0;
	for (; (_x = _temp[_y]) != '\0'; _y++)
		putc(_x, _op1);
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2J(JNIEnv *env, jobject thiz, jstring fullpath, jlong data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != LONG)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	sprintf(_temp, "%lld", (long long int)data);
	__edNum__(_temp, ENC);
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	// printf("%s", __ftmp);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	putc('1', _op1);
	putc(_C_BUKA_, _op1);
	_y = 0;
	for (; (_x = _temp[_y]) != '\0'; _y++)
		putc(_x, _op1);
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2D(JNIEnv *env, jobject thiz, jstring fullpath, jdouble data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != DOUBLE)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	sprintf(_temp, "%lf", (double)data);
	__edNum__(_temp, ENC);
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	// printf("%s", __ftmp);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	putc('1', _op1);
	putc(_C_BUKA_, _op1);
	_y = 0;
	for (; (_x = _temp[_y]) != '\0'; _y++)
		putc(_x, _op1);
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring fullpath, jstring data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != STR)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	const char *val = (data)?(*env) -> GetStringUTFChars(env, data, 0):NULL;
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	if(val){
		sprintf(_temp, "%d", strlen(val));
		for(; _temp[_y] != '\0'; _y++)putc(_temp[_y], _op1);
	}
	else putc('0', _op1);
	putc(_C_BUKA_, _op1);
	if(val){
		if(_en_flags){
			_y = strlen(val) - 1;
			for(; _y >= 0; _y--)putc(__encStr__(val[_y]), _op1);
		}
		else
			for(_y = 0; val[_y] != '\0'; _y++)putc(val[_y], _op1);
	}
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	(*env)->ReleaseStringUTFChars(env, data, val);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2Z(JNIEnv *env, jobject thiz, jstring fullpath, jboolean data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != BOOL)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	int res = __encNum__((data)?'1':'0');
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	putc('1', _op1);
	putc(_C_BUKA_, _op1);
	putc((char)res, _op1);
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setContentData__Ljava_lang_String_2C(JNIEnv *env, jobject thiz, jstring fullpath, jchar data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	char *__getCon_and_path__(char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edNum__(char *, short );
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	register int _y, _x;
	if (!__check_and_pointE__(d , __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	if (_type == _ARR_ID_ || _id != CHR)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	// convert content into _temp
	while ((_x = getc(_open)) != _LEN_);
	off_t _p0 = ftell(_open);
	_y = 0;
	while ((_x = getc(_open)) != _C_TUTUP_);
	off_t _p2 = ftell(_open);
	
	int res = __encStr__((char)data);
	char *__ftmp = malloc(strlen(_filepath) + 4);
	sprintf(__ftmp, "%s.tmp", _filepath);
	FILE *_op1 = fopen(__ftmp, "w+");
	fseek(_open, 0, 0);
	off_t _t = 0;
	for (; _t < _p0; _t++)
		putc(getc(_open), _op1);
	_y = 0;
	putc('1', _op1);
	putc(_C_BUKA_, _op1);
	putc((char)res, _op1);
	fseek(_open, _p2 - 1, 0);
	while ((_x = getc(_open)) != -1)
		putc(_x, _op1);
	fclose(_open);
	fclose(_op1);
	rename(__ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(__ftmp);
	free(_name);
	*_errnum = NE;
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_deleteData(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	ndel_data(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT jboolean JNICALL Java_com_mylexz_utils_NodeData_isAnyErrors(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return FALSE;
	NDATA *d = __lNcont(__lncurr, __desc);
	short a = nget_error(d);
	return (jboolean) ((a)?TRUE:FALSE);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_clearDataValue(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nempty_data(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT jboolean JNICALL Java_com_mylexz_utils_NodeData_isEmptyData(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return FALSE;
	const char *fp;
	if(fullpath == NULL)return FALSE;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short is_e = nis_empty(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return (is_e)?TRUE:FALSE;
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addIntArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jintArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	void __edNum__(char *, short );
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	if (!dt)
	{
		fprintf(_open, "%c%c%d%s%c%d%c", _ARR_ID_, INT, encrypt_flags, _temp, _LEN_, size, _C_BUKA_);
		jint *a = NULL;
		if(data) a = (*env)->GetIntArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%d", ((int) a[x]));
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _open);
			if (x != size - 1) putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
		(*env)->ReleaseIntArrayElements(env, data, a, 0);
	}
	else
	{
		char *__tpath = malloc(strlen(_filepath) + 4);
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		for (; t < offset; t++)
			putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(INT, _op1);
		putc(((encrypt_flags)?'1' : '0'), _op1);
		_y = 0;
		for (; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_LEN_, _op1);
		sprintf(_temp, "%d", size);
		for (_y = 0; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_C_BUKA_, _op1);
		jint *a = NULL;
		if(data) a = (*env)->GetIntArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%d", ((int) a[x]));
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _op1);
			if (x != size - 1) putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while ((_y = getc(_open)) != -1)
			putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__tpath);
		if(a) (*env)->ReleaseIntArrayElements(env, data, a, 0);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);

}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addCharArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jcharArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	int __encNum__(int);
	void __edNum__(char *, short );
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	if (!dt)
	{
		fprintf(_open, "%c%c%d%s%c%d%c", _ARR_ID_, CHR, encrypt_flags, _temp, _LEN_, size, _C_BUKA_);
		jchar *a = NULL;
		if(data) a = (*env)->GetCharArrayElements(env, data, 0);
		int nbl;
		for (x = 0; x < size; x++)
		{
			nbl = (encrypt_flags)? __encStr__((char)a[x]):(char)a[x];
			putc((char)nbl, _open);
			if (x != size - 1) putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
		(*env)->ReleaseCharArrayElements(env, data, a, 0);
	}
	else
	{
		char *__tpath = malloc(strlen(_filepath) + 4);
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		for (; t < offset; t++)
			putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(CHR, _op1);
		putc(((encrypt_flags)?'1' : '0'), _op1);
		_y = 0;
		for (; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_LEN_, _op1);
		sprintf(_temp, "%d", size);
		for (_y = 0; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_C_BUKA_, _op1);
		jchar *a = NULL;
		if(data) a = (*env)->GetCharArrayElements(env, data, 0);
		int nbl;
		for (x = 0; x < size; x++)
		{
			nbl = (encrypt_flags)? __encStr__((char)(a[x])):(char)a[x];
			putc((char)nbl, _op1);
			if (x != size - 1) putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while ((_y = getc(_open)) != -1)
			putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__tpath);
		if(a) (*env)->ReleaseCharArrayElements(env, data, a, 0);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addDoubleArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jdoubleArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	void __edNum__(char *, short );
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	if (!dt)
	{
		fprintf(_open, "%c%c%d%s%c%d%c", _ARR_ID_, DOUBLE, encrypt_flags, _temp, _LEN_, size, _C_BUKA_);
		jdouble *a = NULL;
		if(data) a = (*env)->GetDoubleArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%llf", (double)a[x]);
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _open);
			if (x != size - 1) putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
		(*env)->ReleaseDoubleArrayElements(env, data, a, 0);
	}
	else
	{
		char *__tpath = malloc(strlen(_filepath) + 4);
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		for (; t < offset; t++)
			putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(DOUBLE, _op1);
		putc(((encrypt_flags)?'1' : '0'), _op1);
		_y = 0;
		for (; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_LEN_, _op1);
		sprintf(_temp, "%d", size);
		for (_y = 0; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_C_BUKA_, _op1);
		jdouble *a = NULL;
		if(data) a = (*env)->GetDoubleArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%llf", (double)a[x]);
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _op1);
			if (x != size - 1) putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while ((_y = getc(_open)) != -1)
			putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__tpath);
		if(a) (*env)->ReleaseDoubleArrayElements(env, data, a, 0);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addLongArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jlongArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	void __edNum__(char *, short );
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	if (!dt)
	{
		fprintf(_open, "%c%c%d%s%c%d%c", _ARR_ID_, LONG, encrypt_flags, _temp, _LEN_, size, _C_BUKA_);
		jlong *a = NULL;
		if(data) a = (*env)->GetLongArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%lld", ((long long) a[x]));
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _open);
			if (x != size - 1) putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
		(*env)->ReleaseLongArrayElements(env, data, a, 0);
	}
	else
	{
		char *__tpath = malloc(strlen(_filepath) + 4);
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		for (; t < offset; t++)
			putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(LONG, _op1);
		putc(((encrypt_flags)?'1' : '0'), _op1);
		_y = 0;
		for (; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_LEN_, _op1);
		sprintf(_temp, "%d", size);
		for (_y = 0; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_C_BUKA_, _op1);
		jlong *a = NULL;
		if(data) a = (*env)->GetLongArrayElements(env, data, 0);
		for (x = 0; x < size; x++)
		{
			sprintf(_temp, "%lld", ((long long) a[x]));
			if (encrypt_flags)__edNum__(_temp, ENC);
			for (_y = 0; _temp[_y] != '\0'; _y++)
				putc(_temp[_y], _op1);
			if (x != size - 1) putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while ((_y = getc(_open)) != -1)
			putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__tpath);
		if(a) (*env)->ReleaseLongArrayElements(env, data, a, 0);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addBooleanArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jbooleanArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	int __encNum__(int);
	void __edNum__(char *, short );
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	if (!dt)
	{
		fprintf(_open, "%c%c%d%s%c%d%c", _ARR_ID_, BOOL, encrypt_flags, _temp, _LEN_, size, _C_BUKA_);
		jboolean *a = NULL;
		if(data) a = (*env)->GetBooleanArrayElements(env, data, 0);
		int nbl;
		for (x = 0; x < size; x++)
		{
			nbl = (encrypt_flags)? __encNum__((a[x])?'1':'0'):(a[x])?'1':'0';
			putc((char)nbl, _open);
			if (x != size - 1) putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
		(*env)->ReleaseBooleanArrayElements(env, data, a, 0);
	}
	else
	{
		char *__tpath = malloc(strlen(_filepath) + 4);
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		for (; t < offset; t++)
			putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(BOOL, _op1);
		putc(((encrypt_flags)?'1' : '0'), _op1);
		_y = 0;
		for (; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_LEN_, _op1);
		sprintf(_temp, "%d", size);
		for (_y = 0; _temp[_y] != '\0'; _y++)
			putc(_temp[_y], _op1);
		putc(_C_BUKA_, _op1);
		jboolean *a = NULL;
		if(data) a = (*env)->GetBooleanArrayElements(env, data, 0);
		int nbl;
		for (x = 0; x < size; x++)
		{
			nbl = (encrypt_flags)? __encNum__((a[x])?'1':'0'):(a[x])?'1':'0';
			putc((char)nbl, _op1);
			if (x != size - 1) putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while ((_y = getc(_open)) != -1)
			putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(__tpath);
		if(a) (*env)->ReleaseIntArrayElements(env, data, a, 0);
	}
	fseek(_open, *_sigPos, 0);
	*_errnum = NE;
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addStringArray(JNIEnv *env, jobject thiz, jstring path, jstring name, jobjectArray data, jboolean encrypt_flags){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *elm;
	const char *dt;
	if(name == NULL)return;
	if(path == NULL) dt = NULL;
	else dt = (*env)->GetStringUTFChars(env, path, 0);
	elm = (*env)->GetStringUTFChars(env, name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	
	jsize size = ((data)? (*env)->GetArrayLength(env, data): 0);
	if(!d){
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	if(nisLocked(d)){
		d -> __errnum = EDL;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);

	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	
	struct __nodeName__ *__path = (dt)?__con_pathNode__(dt):NULL;
	if(__check_and_pointE__(d, __path, elm)){
		fseek(_open, *_sigPos, 0);
		*_errnum = EEEx;
		if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
		(*env)->ReleaseStringUTFChars(env, name, elm);
		return;
	}
	strcpy(_temp, elm);
	__edStr__(_temp, ENC);
	register int z, _y, x;
	off_t offset = ftell(_open);
	const char *_cstr = NULL;
	jstring jstr = NULL;
	if(!dt){
		fprintf(_open, "%c%c%d%s%c%d", _ARR_ID_, STR, encrypt_flags, _temp, _LEN_, size);
		if(size > 0)
			putc(_LEN_, _open);
		z = 0;
		// PASS_SLEN
		for(_y = 0; _y < size; _y++){ 
			sprintf(_temp, "%d", (*env) -> GetStringUTFLength(env, (jstring) (*env) -> GetObjectArrayElement(env, data, _y)));
			while(_temp[z] != '\0'){ 
				putc(_temp[z], _open);
				z++;
			}
			z = 0;
			if(_y+1 != size)putc(_LEN_SEP_, _open);
		}
		putc(_C_BUKA_, _open);
		for(_y = 0; _y < size; _y++){
			jstr = (jstring) (*env) -> GetObjectArrayElement(env, data, _y);
			_cstr = (*env) -> GetStringUTFChars(env, jstr, 0);
			if(encrypt_flags){
				z = strlen(_cstr) - 1;
				while(z >= 0){
					x = __encStr__(_cstr[z]);
					putc(x, _open);
					z--;
				}
			}
			else 
				for(z = 0; (x = _cstr[z]) != '\0'; z++) putc(x, _open);
			(*env) -> ReleaseStringUTFChars(env, jstr, _cstr);
			if(_y+1 != size)putc(_ARR_SEP_, _open);
		}
		putc(_C_TUTUP_, _open);
	}
	else {
		char *__tpath = _temp;
		char *__stmp = (_temp + (strlen(_filepath)+5));
		sprintf(__tpath, "%s.tmp", _filepath);
		FILE *_op1 = fopen(__tpath, "w+");
		fseek(_open, 0, 0);
		off_t t = 0;
		//write all contents 
		for(; t < offset; t++) putc(getc(_open), _op1);
		// the header
		putc(_ARR_ID_, _op1);
		putc(STR, _op1);
		putc((((encrypt_flags)?1:0) + '0'), _op1); // en_flags
		// write the name array
		_y = strlen(elm) -1;
		while(_y >= 0)
			putc(__encStr__(elm[_y--]), _op1);
		putc(_LEN_, _op1);
		sprintf(__stmp, "%d", size);
		for(_y = 0; __stmp[_y] != '\0'; _y++)putc(__stmp[_y], _op1);
		if(size > 0)
			putc(_LEN_, _op1);
		z = 0;
		// PASS_SLEN
		for(_y = 0; _y < size; _y++){ 
			sprintf(__stmp, "%d", (*env) -> GetStringUTFLength(env, (jstring) (*env) -> GetObjectArrayElement(env, data, _y)));
			while(__stmp[z] != '\0'){ 
				putc(__stmp[z], _op1);
				z++;
			}
			z = 0;
			if(_y+1 != size)putc(_LEN_SEP_, _op1);
		}
		putc(_C_BUKA_, _op1);
		
		for(_y = 0; _y < size; _y++){
			jstr = (jstring) (*env) -> GetObjectArrayElement(env, data, _y);
			_cstr = (*env) -> GetStringUTFChars(env, jstr, 0);
			if(encrypt_flags){
				z = strlen(_cstr) - 1;
				while(z >= 0){
					x = __encStr__(_cstr[z]);
					putc(x, _op1);
					z--;
				}
			}
			else 
				for(z = 0; (x = _cstr[z]) != '\0'; z++) putc(x, _op1);
			(*env) -> ReleaseStringUTFChars(env, jstr, _cstr);
			if(_y+1 != size)putc(_ARR_SEP_, _op1);
		}
		putc(_C_TUTUP_, _op1);
		while((_y = getc(_open))!=-1)putc(_y, _op1);
		fclose(_op1);
		fclose(_open);
		rename(__tpath, _filepath);
		(d -> __fop).__op1 = _open = fopen(_filepath, "r+");
	}
	if(dt) (*env)->ReleaseStringUTFChars(env, path, dt);
	(*env)->ReleaseStringUTFChars(env, name, elm);
}


JNIEXPORT jintArray JNICALL Java_com_mylexz_utils_NodeData_getIntArray(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);

	NDATA *d = __lNcont(__lncurr, __desc);
	jint size = nget_arrlen(d, fp);
	jintArray arr = (*env) -> NewIntArray(env, size);
	int *marr = nget_arr(d, fp);
	(*env) -> SetIntArrayRegion(env, arr, 0, size, marr);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    getDoubleArray
 * Signature: (Ljava/lang/String;)[D
 */
JNIEXPORT jdoubleArray JNICALL Java_com_mylexz_utils_NodeData_getDoubleArray
(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);

	NDATA *d = __lNcont(__lncurr, __desc);
	jint size = nget_arrlen(d, fp);
	if(!size)return NULL;
	jdoubleArray arr = (*env) -> NewDoubleArray(env, size);
	double *marr = (void *)nget_arr(d, fp);
	jint x = 0;
	jdouble kk[size];
	for(; x < size; x++)kk[x] = (jdouble) marr[x];
	(*env) -> SetDoubleArrayRegion(env, arr, 0, size, (const jdouble *) kk);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    getLongArray
 * Signature: (Ljava/lang/String;)[J
 */
JNIEXPORT jlongArray JNICALL Java_com_mylexz_utils_NodeData_getLongArray
(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);

	NDATA *d = __lNcont(__lncurr, __desc);
	jint size = nget_arrlen(d, fp);
	if(!size)return NULL;
	jlongArray arr = (*env) -> NewLongArray(env, size);
	long long *marr = nget_arr(d, fp);
	(*env) -> SetLongArrayRegion(env, arr, 0, size, marr);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    getBooleanArray
 * Signature: (Ljava/lang/String;)[Z
 */
JNIEXPORT jbooleanArray JNICALL Java_com_mylexz_utils_NodeData_getBooleanArray
(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);

	NDATA *d = __lNcont(__lncurr, __desc);
	jint size = nget_arrlen(d, fp);
	if(!size)return NULL;
	jbooleanArray arr = (*env) -> NewBooleanArray(env, size);
	short *marr = nget_arr(d, fp);
	jboolean cn[size];
	jint n;
	for(n = 0; n < size; n++)
		cn[n] = (marr[n])?TRUE:FALSE;
	(*env) -> SetBooleanArrayRegion(env, arr, 0, size, cn);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}



JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2I(JNIEnv *env, jobject thiz, jstring fullpath, jint data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	int val = (int) data;
	jint res = nget_occur(d, fp, &val);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2J(JNIEnv *env, jobject thiz, jstring fullpath, jlong data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	long long int val = (long long int) data;
	jint res = nget_occur(d, fp, &val);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2D(JNIEnv *env, jobject thiz, jstring fullpath, jdouble data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	double val = (double) data;
	jint res = nget_occur(d, fp, &val);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}
JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring fullpath, jstring data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	const char *val = (*env) -> GetStringUTFChars(env, data, 0);
	void *mvm = (void *) val;
	jint res = nget_occur(d, fp, mvm);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	(*env)->ReleaseStringUTFChars(env, data, val);
	return res;
}

JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2Z(JNIEnv *env, jobject thiz, jstring fullpath, jboolean data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short val = (data)?1:0;
	jint res = nget_occur(d, fp, &val);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getOccurences__Ljava_lang_String_2C(JNIEnv *env, jobject thiz, jstring fullpath, jchar data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	char val = (char) data;
	jint res = nget_occur(d, fp, &val);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}

JNIEXPORT jboolean JNICALL Java_com_mylexz_utils_NodeData_isLocked(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return FALSE;
	NDATA *d = __lNcont(__lncurr, __desc);
	return (nisLocked(d))?TRUE:FALSE;
}

JNIEXPORT jstring JNICALL Java_com_mylexz_utils_NodeData_getErrorDesc(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	NDATA *d = __lNcont(__lncurr, __desc);
	return (*env) -> NewStringUTF(env, ndisplay_error(d));
}
JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getArrayLength(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	const char *fp;
	if(fullpath == NULL)return 0;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jint res = nget_arrlen(d, fp);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return res;
}
JNIEXPORT jint JNICALL Java_com_mylexz_utils_NodeData_getDataType(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return 0;
	if(!fullpath)return 0;
	const char *pth = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short tp = nget_td(d, pth);
	jint ntp;
	switch(tp){
		case INT:
			ntp = com_mylexz_utils_NodeData_TYPE_INT;
		break;
		case STR:
			ntp = com_mylexz_utils_NodeData_TYPE_STRING;
		break;
		case BOOL:
			ntp = com_mylexz_utils_NodeData_TYPE_BOOLEAN;
		break;
		case DOUBLE:
			ntp = com_mylexz_utils_NodeData_TYPE_DOUBLE;
		break;
		case LONG:
			ntp = com_mylexz_utils_NodeData_TYPE_LONG;
		break;
		case CHR:
			ntp = com_mylexz_utils_NodeData_TYPE_CHAR;
		break;
		default:
			ntp = 0;
	}
	(*env) -> ReleaseStringUTFChars(env, fullpath, pth);
	return ntp;
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setReadArrayIteration(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "type", "I");
	jint ftype = (*env)->GetIntField(env, thiz, fid);
	if(ftype)return;
	if(__desc == -1)return;
	
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nreadarr_iter(d, fp);
	if(!nget_error(d)){
		jint tp;
		switch(d -> __id){	
			case INT:
				tp = com_mylexz_utils_NodeData_TYPE_INT;
			break;
			case STR:
				tp = com_mylexz_utils_NodeData_TYPE_STRING;
			break;
		
			case LONG:
				tp = com_mylexz_utils_NodeData_TYPE_LONG;
			break;
			case DOUBLE:
				tp = com_mylexz_utils_NodeData_TYPE_DOUBLE;
			break;
			case CHR:
				tp = com_mylexz_utils_NodeData_TYPE_CHAR;
			break;
			case BOOL:
				tp = com_mylexz_utils_NodeData_TYPE_BOOLEAN;
			break;
			default:
				tp = ftype;
		}
		(*env) -> SetIntField(env, thiz, fid, tp);
	}
	(*env) -> ReleaseStringUTFChars(env, fullpath, fp);
}
JNIEXPORT jobject JNICALL Java_com_mylexz_utils_NodeData_readNext(JNIEnv *env, jobject thiz){
	jclass Except = (*env) -> FindClass(env, "java/lang/Exception");
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1){
		(*env) -> ThrowNew(env, Except, "The Object is not initialized! Consider call the method open()!");
	}
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d)(*env) -> ThrowNew(env, Except, "The Object is not initialized! Consider call the method open()!");
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);

	void __edStr__(char *, short );
	void __edNum__(char *, short );
	int __encStr__(int);
	int __decStr__(int);
	void __mem_rel__(NDATA *);
	if(*_lock != 0) (*env) -> ThrowNew(env, Except, "You must call setReadArrayIteration()! or Index is reaching the end of array");
	register int _x, _y, _z = 0;
	__mem_rel__(d);
	short *_en_f = (d -> __dop).__op2;
	if(d -> __id == STR){
		_y = 0;
		char _result[d -> __arrlen[d -> __arrpos]];
		while((_x = getc(_open)) != _ARR_SEP_ && _x != _C_TUTUP_)
			_result[_y++] = _x;
		_result[_y] = '\0';
		if(*_en_f)
			__edStr__(_result, DEC);
		if(_x == _C_TUTUP_)*_lock = -2;
		d -> __arrpos = d -> __arrpos + 1;
		*_errnum = NE;
		return (*env) -> NewStringUTF(env, _result);
	}
	else {
		_y = 0;
		jclass cls;
		jmethodID mID;
		jobject res;
		while((_x = getc(_open)) != _ARR_SEP_ && _x != _C_TUTUP_)_temp[_y++] = _x;
		_temp[_y] = '\0';
		if(*_en_f)
			if(d -> __id == CHR) {
				_y = _temp[0];
				_temp[0] = __decStr__(_y);
				_y = 0;
			}
			else __edNum__(_temp, DEC);
		_y = 0;
		switch(d -> __id){
			case INT:{
				cls = (*env) -> FindClass(env, "java/lang/Integer");
				mID = (*env) -> GetMethodID(env, cls, "<init>", "(I)V");
				res = (*env) -> NewObject(env, cls, mID, (jint)atoi(_temp));
			}
			break;
			case BOOL:{
				cls = (*env) -> FindClass(env, "java/lang/Boolean");
				mID = (*env) -> GetMethodID(env, cls, "<init>", "(Z)V");
				res = (*env) -> NewObject(env, cls, mID, (jboolean)((atoi(_temp))?TRUE:FALSE));}
			break;
			case CHR:{
				cls = (*env) -> FindClass(env, "java/lang/Character");
				mID = (*env) -> GetMethodID(env, cls, "<init>", "(C)V");
				res = (*env) -> NewObject(env, cls, mID, (jchar)((char)_temp[0]));
				}
				break;
			case LONG:{
				cls = (*env) -> FindClass(env, "java/lang/Long");
				mID = (*env) -> GetMethodID(env, cls, "<init>", "(J)V");
				res = (*env) -> NewObject(env, cls, mID, (jlong)(atoll(_temp)));}
				break;
			case DOUBLE:{
				cls = (*env) -> FindClass(env, "java/lang/Double");
				mID = (*env) -> GetMethodID(env, cls, "<init>", "(D)V");
				res = (*env) -> NewObject(env, cls, mID, (jdouble)(atof(_temp)));}
				break;
			default:
				(*env) -> ThrowNew(env, Except, "Unknown type Format!");
				break;
			}
			if(_x == _C_TUTUP_)*_lock = -2;
			*_errnum = NE;
			d -> __arrpos = d -> __arrpos +1;
		return res;
	}
	return NULL;
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_resetArrayIteration(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	void *data;
	NDATA *d = __lNcont(__lncurr, __desc);
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "type", "I");
	(*env) -> SetIntField(env, thiz, fid, (jint) 0);
	nfinish_read(d);
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_addNodeIter(JNIEnv *env, jobject thiz, jstring path){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!path)return;
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "proc", "I");
	jint ftype = (*env)->GetIntField(env, thiz, fid);
	if(ftype)return;
	(*env) -> SetIntField(env, thiz, fid, (jint) 'c');
	const char *pth = (*env) -> GetStringUTFChars(env, path, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	naddnode_iter(d, pth);
	(*env) -> ReleaseStringUTFChars(env, path, pth);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_nextaddNode(JNIEnv *env, jobject thiz, jstring node_name){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!node_name)return;
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "proc", "I");
	jint ftype = (*env)->GetIntField(env, thiz, fid);
	if(ftype != 'c')return;

	const char *pth = (*env) -> GetStringUTFChars(env, node_name, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nnext_addnode(d, pth);
	(*env) -> ReleaseStringUTFChars(env, node_name, pth);
}
// save iter
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_saveIteration(JNIEnv *env, jobject thiz){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "proc", "I");
	jint ftype = (*env)->GetIntField(env, thiz, fid);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(ftype == 'c')
		nsave(d);
	else if (ftype == 'd'){
		register int x, y;
		if(!d)return;
		if(d -> __lock != -6){d -> __errnum = EDL;return;}
		char *_temp = d -> __temp; 
		struct __nodeName__ *__lastPath = d -> __lastPath; 
		FILE *_open = (d -> __fop).__op1; 
		char *_filepath = d -> __filePath; 
		short *_errnum = &(d -> __errnum); 
		off_t *_sigPos = &(d -> __sigPos); 
		off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
		short *_lock = &(d -> __lock);
		struct __nodeName__ *__con_pathNode__(const char *);
		off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
		void __edStr__(char *, short );
		int __encStr__(int);
		jclass cls2 = (*env)->GetObjectClass(env, thiz);
		jfieldID fid2 = (*env)->GetFieldID(env, cls, "s_tmp", "Ljava/lang/String;");
		jstring dtr = (*env) -> GetObjectField(env, thiz, fid2);
		const char *dtm = (*env) -> GetStringUTFChars(env, dtr, 0);
		short _en_flags = getc(_open) - '0';
		int len;
		while (getc(_open) != _LEN_);
		off_t p1 = ftell(_open);
		y = 0;
		while ((x = getc(_open)) != _C_BUKA_)
			_temp[y++] = x;
		_temp[y] = '\0';
		len = atoi(_temp);
		char *_ctmp = malloc( strlen(dtm) + len);
		y = 0;
		while ((x = getc(_open)) != _C_TUTUP_)
			_ctmp[y++] = x;
		off_t p2 = ftell(_open);
		_ctmp[y] = '\0';
		if (_en_flags)
			__edStr__(_ctmp, DEC);
		strcat(_ctmp, dtm);
		len = strlen(_ctmp);
			// printf("val = %s, length = %d\n\n\n\n\n", _ctmp, len);
			// /////////////// open new file
		if (_en_flags)
			__edStr__(_ctmp, ENC);
		fseek(_open, 0, 0);
		off_t xz = 0;
		char *vmt = _temp + (strlen(_filepath) + 5);
		sprintf(_temp, "%s.tmp", _filepath);
		FILE *_op = fopen(_temp, "w+");
		for (; xz < p1; xz++)
			putc(getc(_open), _op);
		sprintf(vmt, "%d", len);
		for (xz = 0; vmt[xz] != '\0'; xz++)
			putc(vmt[xz], _op);
		putc(_C_BUKA_, _op);
		for (xz = 0; _ctmp[xz] != '\0'; xz++)
			putc(_ctmp[xz], _op);
		fseek(_open, p2 - 1, 0);
		while ((x = getc(_open)) != -1)
			putc(x, _op);
		fclose(_op);
		fclose(_open);
		(d->__dop).__op2 = NULL;
		rename(_temp, _filepath);
		(d->__fop).__op1 = _open = fopen(_filepath, "r+");
		free(_ctmp);
		(*env) -> ReleaseStringUTFChars(env, dtr, dtm);
		fseek(_open, *_sigPos, 0);
		*_lock = -1;
		*_errnum = NE;
	}
}
/********/
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3I(JNIEnv *env, jobject thiz, jstring fullpath, jintArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!data){
		nset_arr(d, fp, NULL, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	jsize len = (*env)->GetArrayLength(env, data);
	jint *a = (*env)->GetIntArrayElements(env, data, 0);
	nset_arr(d, fp, a, len);
	(*env)->ReleaseIntArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    setArray
 * Signature: (Ljava/lang/String;[J)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3J(JNIEnv *env, jobject thiz, jstring fullpath, jlongArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!data){
		nset_arr(d, fp, NULL, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	jsize len = (*env)->GetArrayLength(env, data);
	jlong *a = (*env)->GetLongArrayElements(env, data, 0);
	nset_arr(d, fp, a, len);
	(*env)->ReleaseLongArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    setArray
 * Signature: (Ljava/lang/String;[D)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3D(JNIEnv *env, jobject thiz, jstring fullpath, jdoubleArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!data){
		nset_arr(d, fp, NULL, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	jsize len = (*env)->GetArrayLength(env, data);
	jdouble *a = (*env)->GetDoubleArrayElements(env, data, 0);
	nset_arr(d, fp, a, len);
	(*env)->ReleaseDoubleArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    setArray
 * Signature: (Ljava/lang/String;[C)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3C(JNIEnv *env, jobject thiz, jstring fullpath, jcharArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!data){
		nset_arr(d, fp, NULL, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jchar *a = (*env)->GetCharArrayElements(env, data, 0);
	char elmn[len];
	jint x = 0;
	for(; x < len; x++)
		elmn[x] = (char) a[x];
	elmn[x] = '\0';
	nset_arr(d, fp, (void *) elmn, len);
	(*env)->ReleaseCharArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    setArray
 * Signature: (Ljava/lang/String;[Z)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3Z(JNIEnv *env, jobject thiz, jstring fullpath, jbooleanArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!data){
		nset_arr(d, fp, NULL, 0);
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jboolean *a = (*env)->GetBooleanArrayElements(env, data, 0);
	short res[len];
	jint x;
	for(x = 0; x<len; x++)res[x] = ((a[x])?TRUE:FALSE);
	nset_arr(d, fp, res, len);
	(*env)->ReleaseBooleanArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArray__Ljava_lang_String_2_3Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring fullpath, jobjectArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!fullpath || !data)return;
	const char *path = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	// declare a variables
	if(!d)return;
	if(nisLocked(d)){d -> __errnum = EDL;return;}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, path);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0')?__con_pathNode__(_temp):NULL;
	if(!__check_and_pointE__(d, __path, _name)){
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_f = getc(_open) - '0';
	if(_type != _ARR_ID_ || _id != STR){
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		return;
	}
	register int _x, _y, _z;
	// passing array length
	jint _len = (data)?(*env) -> GetArrayLength(env, data):0;
	///////////
	// point into _LEN_
	while(getc(_open) != _LEN_);
	// save offset point 1
	off_t _p1 = ftell(_open);
	// point into _C_TUTUP_
	while(getc(_open) != _C_TUTUP_);
	// save offset point 2
	off_t _p2 = ftell(_open);
	// point into 0 offset 
	fseek(_open, 0, 0);
	// create temp file and open it
	char *_ftmp = _temp+10;
	sprintf(_ftmp, "%s.tmp", _filepath);
	FILE *_fop = fopen(_ftmp, "w+");
	// pass content from 0 offset into last _LEN_
	off_t _op3 = 0;
	for(; _op3 < _p1; _op3++)putc(getc(_open), _fop);
	// pass array length for identification
	_x = _y = _z = 0;
	sprintf(_temp, "%d", _len);
	_z = strlen(_temp);
	for(; _x < _z; _x++)putc(_temp[_x], _fop);
	_x = _z = 0;
	if(_len > 0)
		putc(_LEN_,_fop);
	for(; _x < _len; _x++){
		sprintf(_temp, "%d", (*env) -> GetStringUTFLength(env, (jstring) (*env) -> GetObjectArrayElement(env, data, _x)));
		_z = strlen(_temp);
		_y = 0;
		for(; _y < _z; _y++)putc(_temp[_y], _fop);
		if((_x+1) != _len)putc(_LEN_SEP_, _fop);
	}
	_x = _y = _z = 0;
	// passing content of array
	putc(_C_BUKA_, _fop);		
	jstring dt;
	for(_x = 0; _x < _len; _x++){
		dt = (jstring) (*env) -> GetObjectArrayElement(env, data, _x);
		const char *content = (*env) -> GetStringUTFChars(env, dt, 0);
		if(_en_f){
			_y = strlen(content) -1;
			while(_y >= 0)putc(__encStr__(content[_y--]), _fop);	
		}
		else 
			for(_y = 0; content[_y] != '\0'; _y++)putc(content[_y], _fop);
		if(_x != _len-1)putc(_ARR_SEP_, _fop);
		else putc(_C_TUTUP_, _fop);
		(*env) -> ReleaseStringUTFChars(env, dt, content);
	}
	// point into second last offset
	fseek(_open, _p2, 0);
	// pass every character until -1
	while((_x = getc(_open)) != -1)putc(_x, _fop);
	// close all files
	fclose(_fop);
	fclose(_open);
	// rename and open old files
	rename(_ftmp, _filepath);	
	(d -> __fop).__op1 = _open = fopen(_filepath, "r+");
	fseek(_open, *_sigPos, 0);
	free(_name);
	*_errnum = NE;
	return;
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3III(JNIEnv *env, jobject thiz, jstring fullpath, jintArray data, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(start > end)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jint *a = (*env)->GetIntArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nset_ap(d, fp, a, len, start, end);
	(*env)->ReleaseIntArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3JII(JNIEnv *env, jobject thiz, jstring fullpath, jlongArray data, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(start > end)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jlong *a = (*env)->GetLongArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nset_ap(d, fp, a, len, start, end);
	(*env)->ReleaseLongArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3DII(JNIEnv *env, jobject thiz, jstring fullpath, jdoubleArray data, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(start > end)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jdouble *a = (*env)->GetDoubleArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nset_ap(d, fp, a, len, start, end);
	(*env)->ReleaseDoubleArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3ZII(JNIEnv *env, jobject thiz, jstring fullpath, jbooleanArray data, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jboolean *a = (*env)->GetBooleanArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short res[len];
	jint x;
	for(x=0; x<len; x++)res[x] = (short) (a[x])?TRUE:FALSE;
	nset_ap(d, fp, res, len, start, end);
	(*env)->ReleaseBooleanArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3CII(JNIEnv *env, jobject thiz, jstring fullpath, jcharArray data, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(start > end)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	jchar *a = (*env)->GetCharArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	char res[len];
	jint x;
	for(x=0; x<len; x++)res[x] = (char)a[x];
	nset_ap(d, fp, res, len, start, end);
	(*env)->ReleaseCharArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
} 

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_setArrayAtPos__Ljava_lang_String_2_3Ljava_lang_String_2II(JNIEnv *env, jobject thiz, jstring fullpath, jobjectArray data, jint start, jint end){
	 // declare a variables
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!fullpath || !data)return;
	const char *path = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	// declare a variables
	if(!d)return;
	if(nisLocked(d)){d -> __errnum = EDL;return;}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	
	
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, path);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0')?__con_pathNode__(_temp):NULL;
	if(!__check_and_pointE__(d, __path, _name)){
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_f = getc(_open) -'0';
	jint size = (*env) -> GetArrayLength(env, data);
	if(_type != _ARR_ID_ || _id != STR || start > end || ((end - start)+1) != size ){
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		return;
	}
	
	
	register int _v, _w, _x, _y, _z;
	register short _lck = 0;
	jint _len;
	_y = _z = 0;
	while(getc(_open) != _LEN_);
	// declare a position
	off_t _p0, _p1;
	while((_x = getc(_open)) != _LEN_ && _x != _C_BUKA_)_temp[_y++] = _x;
	_temp[_y] = '\0';
	_len = atoi(_temp);
	if(((end - start)+1) > _len || end >= _len){
		free(_name);
		*_errnum = ESZ;
		fseek(_open, *_sigPos, 0);
		return;
	}
	jint _arrlen[_len];
	_p0 = ftell(_open);
	_x = _y = _z = 0;
	//_arrlen = malloc(sizeof(int) * (*_len));
	while((_x = getc(_open)) != _C_BUKA_){
		if(_x == _LEN_SEP_){
			_temp[_y] = '\0';
			_y = 0;
			_arrlen[_z++] = atoi(_temp);
		}
		else _temp[_y++] = _x;
	}
	_temp[_y] = '\0';
	_arrlen[_z] = atoi(_temp);
	// change the length of each element in content
	for(_x = start, _y = _z = 0; _x <= end; _x++)
		_arrlen[_x] = (*env) -> GetStringUTFLength(env, (jstring) (*env) -> GetObjectArrayElement(env, data, _y++));
	_x = _y = _z = 0;
	
	// open temporary files
	char *_ftmp = _temp + 10;
	sprintf(_ftmp, "%s.tmp", _filepath);
	FILE *_fop = fopen(_ftmp, "w+");
	// starts writing until offset occurs
	fseek(_open, 0, 0);
	for(_p1 = 0; _p1 < _p0; _p1++)putc(getc(_open), _fop);
	// write the length of each content string of array
	_w = _x = _y = _z = 0;
	for(; _w < _len; _w++){
		sprintf(_temp, "%d", _arrlen[_w]);
		for(; (_y = _temp[_x]) != '\0'; _x++)putc(_y, _fop);
		_x = 0;
		if((_w + 1) != _len)putc(_LEN_SEP_, _fop);
	}
	while(getc(_open) != _C_BUKA_);
	putc(_C_BUKA_, _fop);
	_w = _x = _y = _z = 0;
	// write the content
	_v = _w = _x = _y = _z = 0;
	char *__isi = NULL;
	jstring dt;
	while(TRUE){
		_w = getc(_open);
		if(_w == _ARR_SEP_ || _w == _C_TUTUP_ || _w == -1){
			if(_x != start)_x++;
			if(_y != (end+1))_y++;
			_lck = 0;
		}
		if(_x != start)
			putc(_w, _fop);
		
		if(_x == start && _y != (end+1)){
			if(!_lck){
				dt = (jstring) (*env) -> GetObjectArrayElement(env, data, _z);
				const char *cet = (*env) -> GetStringUTFChars(env, dt, 0);
				if(_w == _ARR_SEP_)putc(_w, _fop);
				// write !!
				if(_en_f){
					_v = strlen(cet) - 1;
					for(; _v >= 0; _v--)putc(__encStr__(cet[_v]), _fop);
				}
				else 
					for(_v = 0; cet[_v] != '\0'; _v++)putc(cet[_v], _fop);
				_z++;
				_lck = 1;
				(*env) -> ReleaseStringUTFChars(env, dt, cet);
			}
		}
		if(_y == (end+1) && _w != _C_TUTUP_)
			putc(_w, _fop);
		
		if(_w == _C_TUTUP_){
			putc(_w, _fop); 
			break;
		}
	}
	
	while((_w = getc(_open)) != -1)putc(_w, _fop);
	fclose(_fop);
	fclose(_open);
	rename(_ftmp, _filepath);
	(d -> __fop).__op1 = _open = fopen(_filepath, "r+");
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	free(_name);
	//free(_ftmp);
	return;	
}


JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3I(JNIEnv *env, jobject thiz, jstring fullpath, jintArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jint *a = (*env)->GetIntArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nappend_arr(d, fp, a, len);
	(*env)->ReleaseIntArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    appendArray
 * Signature: (Ljava/lang/String;[J)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3J(JNIEnv *env, jobject thiz, jstring fullpath, jlongArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jlong *a = (*env)->GetLongArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nappend_arr(d, fp, a, len);
	(*env)->ReleaseLongArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    appendArray
 * Signature: (Ljava/lang/String;[D)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3D(JNIEnv *env, jobject thiz, jstring fullpath, jdoubleArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jdouble *a = (*env)->GetDoubleArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nappend_arr(d, fp, a, len);
	(*env)->ReleaseDoubleArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    appendArray
 * Signature: (Ljava/lang/String;[C)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3C(JNIEnv *env, jobject thiz, jstring fullpath, jcharArray data){
		jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jchar *a = (*env)->GetCharArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	char elmn[len];
	jint x = 0;
	for(; x < len; x++)
		elmn[x] = (char) a[x];
	elmn[x] = '\0';
	nappend_arr(d, fp, (void *) elmn, len);
	(*env)->ReleaseCharArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}

/*
 * Class:     com_mylexz_utils_NodeData
 * Method:    appendArray
 * Signature: (Ljava/lang/String;[Z)V
 */
JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3Z(JNIEnv *env, jobject thiz, jstring fullpath, jbooleanArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	const char *fp;
	if(fullpath == NULL)return;
	if(data == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	jsize len = (*env)->GetArrayLength(env, data);
	if(!len)return;
	jboolean *a = (*env)->GetBooleanArrayElements(env, data, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short res[len];
	jint x;
	for(x = 0; x<len; x++)res[x] = ((a[x])?TRUE:FALSE);
	nappend_arr(d, fp, res, len);
	(*env)->ReleaseBooleanArrayElements(env, data, a, 0);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
}


JNIEXPORT jintArray JNICALL Java_com_mylexz_utils_NodeData_getIntArrayAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	if(start > end)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = (end - start) + 1;
	void *nARrr = nget_ap(d, fp, start, end);
	if(!nARrr){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	int *nArr = (int *) nARrr;
	jintArray arr = (*env) -> NewIntArray(env, size);
	(*env) -> SetIntArrayRegion(env, arr, 0, size, nArr);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

JNIEXPORT jcharArray JNICALL Java_com_mylexz_utils_NodeData_getCharArrayAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	if(start > end)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = (end - start) + 1;
	void *nARrr = nget_ap(d, fp, start, end);
	if(!nARrr){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	char *nArr = (char *) nARrr;
	jchar cArr[size];
	int z = 0;
	for(; z < size; z++) cArr[z] = (jchar) nArr[z];
	const jchar *tyt = (const jchar *) cArr;
	jcharArray arr = (*env) -> NewCharArray(env, size);
	(*env) -> SetCharArrayRegion(env, arr, 0, size, tyt);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

JNIEXPORT jdoubleArray JNICALL Java_com_mylexz_utils_NodeData_getDoubleArrayAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	if(start > end)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = (end - start) + 1;
	void *nARrr = nget_ap(d, fp, start, end);
	if(!nARrr){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	double *nArr = (double *) nARrr;
	jdoubleArray arr = (*env) -> NewDoubleArray(env, size);
	(*env) -> SetDoubleArrayRegion(env, arr, 0, size, nArr);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

JNIEXPORT jlongArray JNICALL Java_com_mylexz_utils_NodeData_getLongArrayAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	if(start > end)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = (end - start) + 1;
	void *nARrr = nget_ap(d, fp, start, end);
	if(!nARrr){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	long long int *nArr = (long long int *) nARrr;
	jlongArray arr = (*env) -> NewLongArray(env, size);
	(*env) -> SetLongArrayRegion(env, arr, 0, size, nArr);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

JNIEXPORT jbooleanArray JNICALL Java_com_mylexz_utils_NodeData_getBooleanArrayAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return NULL;
	if(start > end)return NULL;
	const char *fp;
	if(fullpath == NULL)return NULL;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	jsize size = (end - start) + 1;
	void *nARrr = nget_ap(d, fp, start, end);
	if(!nARrr){
		(*env)->ReleaseStringUTFChars(env, fullpath, fp);
		return NULL;
	}
	short *nArr = (short *) nARrr;
	jbooleanArray arr = (*env) -> NewBooleanArray(env, size);
	jboolean res[size];
	jint x = 0;
	for(; x < size; x++)res[x] = (nArr[x])?TRUE:FALSE;
	(*env) -> SetBooleanArrayRegion(env, arr, 0, size, res);
	(*env)->ReleaseStringUTFChars(env, fullpath, fp);
	return arr;
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_strCatIter(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "proc", "I");
	jint ftype = (*env)->GetIntField(env, thiz, fid);
	if(ftype)return;
	if(__desc == -1)return;
	
	const char *fp;
	if(fullpath == NULL)return;
	fp = (*env)->GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	if(!d)return;
	if(nisLocked(d)){d -> __errnum = EDL;return;}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	void __mem_rel__(NDATA *);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, fp);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	off_t chk = __check_and_pointE__(d, __path, _name);
	//printf("chk : %d, fp : %s, _name = %s", chk, fp, _name);
	if (!chk)
	{
		fseek(_open, *_sigPos, 0);
	//	printf("\nEENF");
		 //printf("\n*&&&&* name %s temp %s chk %d \n", _name, _temp, chk);
		free(_name);
		*_errnum = EENF;
		(*env) -> ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	__mem_rel__(d);
	short _type, _id;
	_type = getc(_open);
	_id = getc(_open);
	if (_type == _ARR_ID_ || _id != STR)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env) -> ReleaseStringUTFChars(env, fullpath, fp);
		return;
	}
	*_lock = -6;
	*_errnum = NE;
	free(_name);
	(*env) -> SetIntField(env, thiz, fid, 'd');
	(*env) -> ReleaseStringUTFChars(env, fullpath, fp);
	return;
}

JNIEXPORT jboolean JNICALL Java_com_mylexz_utils_NodeData_isElementExists(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return FALSE;
	if(!fullpath)return FALSE;
	const char *pth = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	short tp = nis_exists(d, pth);
	(*env) -> ReleaseStringUTFChars(env, fullpath, pth);
	return (tp)?TRUE:FALSE;
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_clearArrayValue(JNIEnv *env, jobject thiz, jstring fullpath){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!fullpath)return;
	const char *pth = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	nempty_arr(d, pth);
	(*env) -> ReleaseStringUTFChars(env, fullpath, pth);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_deleteArrAtPos(JNIEnv *env, jobject thiz, jstring fullpath, jint start, jint end){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!fullpath)return;
	const char *pth = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	ndel_ap(d, pth, (int)start, (int)end);
	(*env) -> ReleaseStringUTFChars(env, fullpath, pth);
}

JNIEXPORT void JNICALL Java_com_mylexz_utils_NodeData_appendArray__Ljava_lang_String_2_3Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring fullpath, jobjectArray data){
	jint __desc = __getNDesc(env, thiz);
	if(__desc == -1)return;
	if(!fullpath || !data)return;
	const char *path = (*env) -> GetStringUTFChars(env, fullpath, 0);
	NDATA *d = __lNcont(__lncurr, __desc);
	// declare a variables
	if(!d)return;
	if(nisLocked(d)){d -> __errnum = EDL;return;}
	char *_temp = d -> __temp; 
	struct __nodeName__ *__lastPath = d -> __lastPath; 
	FILE *_open = (d -> __fop).__op1; 
	char *_filepath = d -> __filePath; 
	short *_errnum = &(d -> __errnum); 
	off_t *_sigPos = &(d -> __sigPos); 
	off_t *_lastNodeLoc = &(d -> __lastNodeLoc); 
	short *_lock = &(d -> __lock);
	struct __nodeName__ *__con_pathNode__(const char *);
	off_t __check_and_pointE__(NDATA *, struct __nodeName__ * , const char *);
	char *__getCon_and_path__(char *);
	void __edStr__(char *, short );
	int __encStr__(int);
	// get the current name elements and passing into dynamic memory
	strcpy(_temp, path);
	char *__name = __getCon_and_path__(_temp);
	char *_name = malloc(strlen(__name));
	strcpy(_name, __name);
	struct __nodeName__ *__path = (_temp[0] != '\0') ? __con_pathNode__(_temp) : NULL;
	if (!__check_and_pointE__(d, __path, _name))
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = EENF;
		(*env) -> ReleaseStringUTFChars(env, fullpath, path);
		return;
	}
	if (!data)
	{
		fseek(_open, *_sigPos, 0);
		free(_name);
		*_errnum = N_VAL;
		(*env) -> ReleaseStringUTFChars(env, fullpath, path);
		return;
	}
	short _type = getc(_open);
	short _id = getc(_open);
	short _en_flags = getc(_open) - '0';
	jsize size = (*env) -> GetArrayLength(env, data);
	if (_type != _ARR_ID_ || _id != STR || size < 1)
	{
		free(_name);
		*_errnum = EIAT;
		fseek(_open, *_sigPos, 0);
		(*env) -> ReleaseStringUTFChars(env, fullpath, path);
		return;
	}
	register int _x, _y, _z;
	register short _lck = 0;
	int _len;
	_y = _z = 0;
	while (getc(_open) != _LEN_);
	// declare a position
	off_t _p0 = ftell(_open), _p1;
	while ((_x = getc(_open)) != _LEN_ && _x != _C_BUKA_)
		_temp[_y++] = _x;
	_temp[_y] = '\0';
	_len = atoi(_temp);
	_x = _y = _z = 0;
	int _arrlen[_len + size];
	while ((_x = getc(_open)) != _C_BUKA_)
	{
		if (_x == _LEN_SEP_)
		{
			_temp[_y] = '\0';
			_y = 0;
			_arrlen[_z++] = atoi(_temp);
		}
		else
			_temp[_y++] = _x;
	}
	_temp[_y] = '\0';
	_arrlen[_z++] = atoi(_temp);
	_y = 0;
	for (_x = 0; _x < size; _x++)
		_arrlen[_z++] = (*env) -> GetStringUTFLength(env, (jstring) (*env) -> GetObjectArrayElement(env, data, _y++));
	char *_ftmp = _temp;
	char *_vtm = _temp + strlen(_filepath) + 5;
	sprintf(_ftmp, "%s.tmp", _filepath);
	FILE *_fop = fopen(_ftmp, "w+");
	fseek(_open, 0, 0);
	for (_p1 = 0; _p1 < _p0; _p1++)
		putc(getc(_open), _fop);
	// passing length of array
	sprintf(_vtm, "%d", (_len + size));
	_y = 0;
	while ((_x = _vtm[_y++]) != '\0')
		putc(_x, _fop);
	// passing str len
	putc(_LEN_, _fop);
	_x = size + _len;
	for (_y = _z = 0; _y < _x; _y++)
	{
		sprintf(_vtm, "%d", _arrlen[_y]);
		while (_vtm[_z] != '\0')
			putc(_vtm[_z++], _fop);
		_z = 0;
		if (_y + 1 != _x)
			putc(_LEN_SEP_, _fop);
	}
	putc(_C_BUKA_, _fop);
	// point _open into _C_BUKA_
	while (getc(_open) != _C_BUKA_);
	// put any content before _C_TUTUP_ into _fop
	while ((_x = getc(_open)) != _C_TUTUP_)
		putc(_x, _fop);
	jstring dt = NULL;
	for (_x = _y = _z = 0; _x < size; _x++)
	{
		putc(_ARR_SEP_, _fop);
		dt = (jstring) (*env) -> GetObjectArrayElement(env, data, _x);
		const char *content = (*env) -> GetStringUTFChars(env, dt, 0);
		if (_en_flags){
			_y = strlen(content) -1;
			while(_y >= 0)putc(__encStr__(content[_y--]), _fop);	
		}
		else 
			for(_y = 0; content[_y] != '\0'; _y++)putc(content[_y], _fop);
		(*env) -> ReleaseStringUTFChars(env, dt, content);
	}
	putc(_C_TUTUP_, _fop);
	while ((_x = getc(_open)) != -1)
		putc(_x, _fop);
	fclose(_fop);
	fclose(_open);
	rename(_ftmp, _filepath);
	(d ->__fop).__op1 = _open = fopen(_filepath, "r+");
	*_errnum = NE;
	fseek(_open, *_sigPos, 0);
	free(_name);
	return;
}

/******/
  
jint __getNDesc(JNIEnv *env, jobject thiz){
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "__id", "I");
	return (*env)->GetIntField(env, thiz, fid);
	 
}
void __setNDesc(JNIEnv *env, jobject thiz, jint val){
	jclass cls = (*env)->GetObjectClass(env, thiz);
	jfieldID fid = (*env)->GetFieldID(env, cls, "__id", "I");
	(*env)->SetIntField(env, thiz, fid, val);
	 
}
lNDATA *__insertlN(lNDATA *curr, lNDATA *tmp){
	if(!curr)return tmp;
	curr -> ptr = __insertlN(tmp, curr -> ptr);
}
lNDATA *__relNode(lNDATA *curr, int __desc){
	lNDATA *tmp;
	if(!curr) return curr;
	if(curr -> __desc == __desc)
	{
		nclose((curr->data));
		tmp = curr;
		curr = curr->ptr;
		free(tmp);
		return(curr);
	}
	curr -> ptr = __relNode(curr -> ptr, __desc);
	return(curr);
}
lNDATA *__creatNode(){
	return (lNDATA *) malloc(sizeof(lNDATA));
}
NDATA *__lNcont(lNDATA *curr, int __desc){
	if(__desc == -1)return NULL;
	NDATA *addr = NULL;
	while(curr){
		if(curr -> __desc == __desc){
			addr = (curr -> data);
			break;
		}
		curr = curr -> ptr;
	}
	return addr;
}
int __genDesc(lNDATA *curr){
	if(curr == NULL)return 0;
	int __desc;
	while(curr){
		__desc = curr -> __desc;
		curr = curr -> ptr;
	}
	return ++__desc;
}
#endif
